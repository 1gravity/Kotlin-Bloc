"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9735],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return f}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(n),f=i,m=d["".concat(c,".").concat(f)]||d[f]||p[f]||r;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8333:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return o},default:function(){return p},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return s}});var a=n(3117),i=(n(7294),n(3905));const r={id:"bloc",title:"Bloc (Business Logic Component)",sidebar_label:"Overview",hide_title:!0},o=void 0,l={unversionedId:"architecture/bloc/bloc",id:"architecture/bloc/bloc",title:"Bloc (Business Logic Component)",description:"Overview",source:"@site/docs/architecture/bloc/bloc.md",sourceDirName:"architecture/bloc",slug:"/architecture/bloc/",permalink:"/Kotlin-Bloc/docs/architecture/bloc/",draft:!1,tags:[],version:"current",frontMatter:{id:"bloc",title:"Bloc (Business Logic Component)",sidebar_label:"Overview",hide_title:!0},sidebar:"architectureSidebar",previous:{title:"Overview",permalink:"/Kotlin-Bloc/docs/architecture/"},next:{title:"Reducer",permalink:"/Kotlin-Bloc/docs/architecture/bloc/reducer"}},c={},s=[{value:"Overview",id:"overview",level:2},{value:"Public Interface",id:"public-interface",level:2},{value:"State Stream",id:"state-stream",level:3},{value:"SideEffect Stream",id:"sideeffect-stream",level:3},{value:"Sink",id:"sink",level:3},{value:"Reducer",id:"reducer",level:2},{value:"Side Effect",id:"side-effect",level:2},{value:"Thunk",id:"thunk",level:2},{value:"Initializer",id:"initializer",level:2}],u={toc:s};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Bloc Architecture - Details",src:n(5356).Z,width:"2369",height:"1559"})),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"Bloc")," implements the app's business logic. It processes event data (called ",(0,i.kt)("inlineCode",{parentName:"p"},"Action"),") from the view / ui component and:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"updates ",(0,i.kt)("inlineCode",{parentName:"li"},"State")," according to its business rules and emits the updated ",(0,i.kt)("inlineCode",{parentName:"li"},"State")," to be consumed by the view / ui component."),(0,i.kt)("li",{parentName:"ol"},"optionally creates ",(0,i.kt)("inlineCode",{parentName:"li"},"SideEffect(s)")," which can be consumed by the view / ui component (e.g. for navigation) or by other consumers (analytics events, logging etc.).")),(0,i.kt)("h2",{id:"public-interface"},"Public Interface"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc")," implements three public facing functions."),(0,i.kt)("h3",{id:"state-stream"},"State Stream"),(0,i.kt)("p",null,"A stream to observe ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," called a ",(0,i.kt)("inlineCode",{parentName:"p"},"StateStream"),". It's similar to ",(0,i.kt)("a",{parentName:"p",href:"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/"},"StateFlow")," but doesn't expose the ",(0,i.kt)("inlineCode",{parentName:"p"},"replayCache")," and doesn't ",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html"},"conflate values"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"public val value: State\npublic suspend fun collect(collector: FlowCollector<State>)\n")),(0,i.kt)("p",null,"While ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," is used to retrieve the current ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"collect")," function is used to collect the flow of ",(0,i.kt)("inlineCode",{parentName:"p"},"States")," emitted by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc"),". "),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"StateStream")," emits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"no duplicate values"),(0,i.kt)("li",{parentName:"ul"},"an initial value upon subscription (analogous ",(0,i.kt)("inlineCode",{parentName:"li"},"BehaviorSubject"),")")),(0,i.kt)("h3",{id:"sideeffect-stream"},"SideEffect Stream"),(0,i.kt)("p",null,"A stream to observe ",(0,i.kt)("inlineCode",{parentName:"p"},"SideEffects")," called a ",(0,i.kt)("inlineCode",{parentName:"p"},"SideEffectStream"),". It's identical to ",(0,i.kt)("a",{parentName:"p",href:"https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/"},"Flow"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"public suspend fun collect(collector: FlowCollector<SideEffect>)\n")),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"SideEffectStream")," emits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"all values, even duplicates"),(0,i.kt)("li",{parentName:"ul"},"no initial value upon subscription (analogous ",(0,i.kt)("inlineCode",{parentName:"li"},"PublishSubject"),")")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Because ",(0,i.kt)("inlineCode",{parentName:"p"},"StateStream")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SideEffectStream")," have a function with the same signature -> ",(0,i.kt)("inlineCode",{parentName:"p"},"collect(FlowCollector)"),", the latter is accessible through the bloc's ",(0,i.kt)("inlineCode",{parentName:"p"},"sideEffects")," property while the former is implemented by the bloc directly:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"bloc.collect { /* observe State here */ }\nbloc.sideEffects.collect { /* observe side effects here */ }\n"))),(0,i.kt)("p",null,"There's no need to call above functions directly. There are extension functions / wrappers that make observing blocs very easy -> ",(0,i.kt)("a",{parentName:"p",href:"../extensions/overview"},"Extensions"),"."),(0,i.kt)("h3",{id:"sink"},"Sink"),(0,i.kt)("p",null,"A sink to send data / ",(0,i.kt)("inlineCode",{parentName:"p"},"Actions")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"public fun send(action: Action)\n")),(0,i.kt)("p",null,"While this is not a suspending function, it immediately returns after adding the action to a queue / channel."),(0,i.kt)("h2",{id:"reducer"},"Reducer"),(0,i.kt)("p",null,"Processing an ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," usually means invoking a ",(0,i.kt)("inlineCode",{parentName:"p"},"Reducer"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A reducer is a function that receives the current state and an action object, decides how to update the state if necessary, and returns the new state: (state, action) => newState",(0,i.kt)("br",{parentName:"p"}),"\n","(",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow"},"https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow"),")")),(0,i.kt)("p",null,"Above definition is the official Redux reducer definition and captures its essence. Reducers in the context of ",(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc")," are very similar: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"(State, Action) -> Proposal\n")),(0,i.kt)("p",null,"Compared to a Redux reducer, this one returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Proposal")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),". More details can be found in ",(0,i.kt)("a",{parentName:"p",href:"./bloc/reducer"},"Reducer"),"."),(0,i.kt)("h2",{id:"side-effect"},"Side Effect"),(0,i.kt)("p",null,'Side effects are created by "special" reducers that return an ',(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," object. "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Effects")," are simple data classes encapsulating the new proposed state and a list of side effects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"public data class Effect<Proposal : Any, SideEffect : Any>(\n    val proposal: Proposal?,\n    val sideEffects: List<SideEffect>\n)\n")),(0,i.kt)("p",null,'The difference between a "regular" reducer and one with side effects is simply the nature of its ',(0,i.kt)("inlineCode",{parentName:"p"},"Proposal"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// no side effects\n(State, Action) -> Proposal\n\n// with side effects\n(State, Action) -> Effect<Proposal, SideEffect>\n")),(0,i.kt)("p",null,"When the framework detects an ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," it will emit the side effects to a dedicated ",(0,i.kt)("inlineCode",{parentName:"p"},"Stream")," that can be observed separately from the regular ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),' stream. There\'s a DSL that make it easy to "build" reducers with side effects (see ',(0,i.kt)("a",{parentName:"p",href:"./bloc/reducer"},"Reducer"),")."),(0,i.kt)("h2",{id:"thunk"},"Thunk"),(0,i.kt)("p",null,"Reducers are synchronous in nature and their intended purpose is to update ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),' right away to make sure the user interface is responsive to user input and updates "without" perceptible delay. Longer running operations should be executed using a ',(0,i.kt)("inlineCode",{parentName:"p"},"Thunk"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'The word "thunk" is a programming term that means "a piece of code that does some delayed work". Rather than execute some logic now, we can write a function body or code that can be used to perform the work later.',(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/usage/writing-logic-thunks"},"https://redux.js.org/usage/writing-logic-thunks"))),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Thunk")," in the context of ",(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc"),' is exactly what above definition implies, although its implementation and especially its execution is completely different from a Redux thunk. While the latter is a function, dispatched as an action to a Redux store and processed by the redux-thunk middleware, "our" thunk is not dispatched as an action but triggered the same way a reducer is triggered, by reacting to an ',(0,i.kt)("inlineCode",{parentName:"p"},"Action")," that was sent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc"),". On top of that it's also:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"a suspending function"),(0,i.kt)("li",{parentName:"ol"},'actions are dispatched to the "next" thunk or reducer in the execution chain')),(0,i.kt)("p",null,"Details can be found in ",(0,i.kt)("a",{parentName:"p",href:"./bloc/thunk"},"Thunk"),"."),(0,i.kt)("h2",{id:"initializer"},"Initializer"),(0,i.kt)("p",null,"Initializers are functions executed when the bloc is created. They are similar to thunks since they can execute asynchronous code and dispatch actions to be processed by other thunks and reducers. Unlike thunks, initializers are executed once and once only during the ",(0,i.kt)("a",{parentName:"p",href:"./bloc/lifecycle"},"Lifecycle")," of a bloc."),(0,i.kt)("p",null,"Details can be found in ",(0,i.kt)("a",{parentName:"p",href:"./bloc/initializer"},"Initializer"),"."))}p.isMDXComponent=!0},5356:function(e,t,n){t.Z=n.p+"assets/images/Bloc Architecture - Bloc Details-fcb5ba9de5a676b5a4befa3ce7090f6c.svg"}}]);