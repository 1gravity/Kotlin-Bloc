"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[444],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),u=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(c.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=u(n),h=i,k=d["".concat(c,".").concat(h)]||d[h]||s[h]||r;return n?a.createElement(k,o(o({ref:t},p),{},{components:n})):a.createElement(k,o({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5437:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return s}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],l={id:"thunk",title:"Thunk",sidebar_label:"Thunk",hide_title:!0},c=void 0,u={unversionedId:"architecture/bloc/thunk",id:"architecture/bloc/thunk",title:"Thunk",description:"Definition",source:"@site/docs/architecture/bloc/thunk.md",sourceDirName:"architecture/bloc",slug:"/architecture/bloc/thunk",permalink:"/Kotlin-Bloc/docs/architecture/bloc/thunk",draft:!1,tags:[],version:"current",frontMatter:{id:"thunk",title:"Thunk",sidebar_label:"Thunk",hide_title:!0},sidebar:"architectureSidebar",previous:{title:"Reducer",permalink:"/Kotlin-Bloc/docs/architecture/bloc/reducer"},next:{title:"Initializer",permalink:"/Kotlin-Bloc/docs/architecture/bloc/initializer"}},p={},s=[{value:"Definition",id:"definition",level:2},{value:"Context",id:"context",level:3},{value:"CoroutineScope",id:"coroutinescope",level:4},{value:"Execution",id:"execution",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Example 3",id:"example-3",level:3}],d={toc:s};function h(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"definition"},"Definition"),(0,r.kt)("p",null,"To reiterate:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'The word "thunk" is a programming term that means "a piece of code that does some delayed work". Rather than execute some logic now, we can write a function body or code that can be used to perform the work later.',(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"https://redux.js.org/usage/writing-logic-thunks"},"https://redux.js.org/usage/writing-logic-thunks"))),(0,r.kt)("p",null,"While a Redux thunk is a function, dispatched as an action to a Redux store and processed by the redux-thunk middleware, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc")," thunk is not dispatched as an action but triggered the same way a reducer is triggered, by reacting to an ",(0,r.kt)("inlineCode",{parentName:"p"},"Action")," that was sent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Bloc"),". On top of that it's also:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"a suspending function"),(0,r.kt)("li",{parentName:"ol"},"takes a CoroutineScope as parameter (next to the ",(0,r.kt)("inlineCode",{parentName:"li"},"GetState"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Action")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Dispatcher")," parameters)"),(0,r.kt)("li",{parentName:"ol"},'Actions are dispatched to the "next" thunk or reducer in the execution chain ')),(0,r.kt)("h3",{id:"context"},"Context"),(0,r.kt)("p",null,"A thunk is called with a ",(0,r.kt)("inlineCode",{parentName:"p"},"ThunkContext")," as receiver. The context is giving access to the current ",(0,r.kt)("inlineCode",{parentName:"p"},"State"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"Action")," that triggered the thunk's execution, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Dispatcher")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineScope"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"public data class ThunkContext<State, Action>(\n    val getState: GetState<State>,\n    val action: Action,\n    val dispatch: Dispatcher<Action>,\n    val coroutineScope: CoroutineScope\n)\n")),(0,r.kt)("p",null,"A typical thunk would evaluate the action, run some asynchronous operation and dispatch actions to be processed by other thunks or reducers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"thunk {\n    if (action == Load) {\n        dispatch(Loading)\n        val nextAction = repository.load().toAction()\n        dispatch(nextAction)\n    } else {\n        // without this no action would reach the reducers below\n        // because this is a catch-all thunk\n        dispatch(action)\n    }\n}\n\nreduce<Loading> { \n    state.copy(loading = true)\n}\n\nreduce<LoadComplete> { \n    state.copy(loading = false, books = action.result)\n}\n")),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The catch-all ",(0,r.kt)("inlineCode",{parentName:"p"},"thunk { }")," needs to call ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(action)")," explicitly or no reducers will be executed (see ",(0,r.kt)("a",{parentName:"p",href:"#execution"},"Execution"),"). "))),(0,r.kt)("p",null,"In this case using a single action thunk would be simpler though and you'd write:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"thunk<Load> {\n    dispatch(Loading)\n    val nextAction = repository.load().toAction()\n    dispatch(nextAction)\n}\n")),(0,r.kt)("p",null,"This doesn't require to call ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch(action)")," explicitly since it only catches a single action (",(0,r.kt)("inlineCode",{parentName:"p"},"Load"),") and then dispatches its own actions."),(0,r.kt)("h4",{id:"coroutinescope"},"CoroutineScope"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineScope")," can be used if coroutines / jobs need to be manually controlled, e.g. to launch/cancel asynchronous operations when a thunk is triggered multiple times like in this example (not a thread-safe implementation):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"private var loadingJob: Job? = null\n\n// the user can select multiple posts within a brief period of time\nfun onSelected(post: Post) = thunk {\n    \n    // only load if not already being loaded and if a different post was selected\n    if (loadingJob != null && state.id != post.id) {\n        \n        // we cancel a previous loading job before starting a new one\n        loadingJob?.cancel()\n        loadingJob = coroutineScope.launch {\n            load(post)\n        }\n    }\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"CoroutineScope")," is tied to the lifecycle of the bloc and will be cancelled when the bloc is destroyed."),(0,r.kt)("h2",{id:"execution"},"Execution"),(0,r.kt)("p",null,"A lot of what was said in the ",(0,r.kt)("a",{parentName:"p",href:"reducer#execution"},"reducer documentation")," applies to ",(0,r.kt)("inlineCode",{parentName:"p"},"thunks")," too but there are important differences. Here are the rules:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If there's more than one reducer matching an action, only the first one will be executed (can't reduce the same state twice).",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"Rule 1"),": for thunks, ",(0,r.kt)("strong",{parentName:"li"},"every matching thunk will be executed"),"."),(0,r.kt)("li",{parentName:"ol"},"Reducers are executed by matching action, the order of declaration only matters when there's more than one matching reducer.",(0,r.kt)("br",{parentName:"li"}),(0,r.kt)("strong",{parentName:"li"},"Rule 2"),": for thunks, ",(0,r.kt)("strong",{parentName:"li"},"the order of declaration is crucial")," in determining which one executes first especially because every matching thunk will be executed (rule 1)."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Rule 3"),": when a thunk dispatches an action, it's dispatched to all matching thunks declared after the dispatching thunk (or we would end up with an endless loop). If no matching thunk is found, the action is dispatched to the first matching reducer.")),(0,r.kt)("h3",{id:"example-1"},"Example 1"),(0,r.kt)("p",null,"An example of rule 1 and 2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'thunk<Increment> {\n    println("thunk 1")\n}\n\nthunk<Increment> {\n    println("thunk 2")\n}\n\nthunk {\n    println("thunk 3")\n}\n\nreduce {\n    println("reducer")\n    state\n}\n')),(0,r.kt)("p",null,"Above thunks will all be executed in the order of their declaration (sequentially). The output will be:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"thunk 1",(0,r.kt)("br",{parentName:"p"}),"\n","thunk 2",(0,r.kt)("br",{parentName:"p"}),"\n","thunk 3")),(0,r.kt)("p",null,"The reducer won't be executed as none of the thunks dispatches any action. "),(0,r.kt)("h3",{id:"example-2"},"Example 2"),(0,r.kt)("p",null,"Try to guess what happens when the first thunk dispatches an ",(0,r.kt)("inlineCode",{parentName:"p"},"Increment")," action (all three rules apply):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'thunk<Increment> {\n    println("thunk 1")\n    dispatch(Increment)\n}\n\nthunk<Increment> {\n    println("thunk 2")\n}\n\nthunk {\n    println("thunk 3")\n}\n\nreduce {\n    println("reducer")\n    state\n}\n')),(0,r.kt)("p",null,"The output will be:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"thunk 1",(0,r.kt)("br",{parentName:"p"}),"\n","thunk 2",(0,r.kt)("br",{parentName:"p"}),"\n","thunk 3",(0,r.kt)("br",{parentName:"p"}),"\n","thunk 2",(0,r.kt)("br",{parentName:"p"}),"\n","thunk 3")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the original ",(0,r.kt)("inlineCode",{parentName:"li"},"Increment")," action is dispatched to the first thunk",(0,r.kt)("br",{parentName:"li"}),"-> outputs: ",(0,r.kt)("inlineCode",{parentName:"li"},"thunk 1")),(0,r.kt)("li",{parentName:"ul"},"the first thunk dispatches a second ",(0,r.kt)("inlineCode",{parentName:"li"},"Increment")," action to all matching thunks declared after the dispatching thunk (rule 3)"),(0,r.kt)("li",{parentName:"ul"},"thunk 2 is the first to process the second ",(0,r.kt)("inlineCode",{parentName:"li"},"Increment")," action",(0,r.kt)("br",{parentName:"li"}),"-> outputs: ",(0,r.kt)("inlineCode",{parentName:"li"},"thunk 2")),(0,r.kt)("li",{parentName:"ul"},"thunk 3 is next in line to process the second ",(0,r.kt)("inlineCode",{parentName:"li"},"Increment")," action",(0,r.kt)("br",{parentName:"li"}),"-> outputs: ",(0,r.kt)("inlineCode",{parentName:"li"},"thunk 3")),(0,r.kt)("li",{parentName:"ul"},"the original ",(0,r.kt)("inlineCode",{parentName:"li"},"Increment")," action is dispatched to the second thunk",(0,r.kt)("br",{parentName:"li"}),"-> outputs: ",(0,r.kt)("inlineCode",{parentName:"li"},"thunk 2")),(0,r.kt)("li",{parentName:"ul"},"the original ",(0,r.kt)("inlineCode",{parentName:"li"},"Increment")," action is dispatched to the third thunk",(0,r.kt)("br",{parentName:"li"}),"-> outputs: ",(0,r.kt)("inlineCode",{parentName:"li"},"thunk 3")),(0,r.kt)("li",{parentName:"ul"},"nothing reaches the reducer")),(0,r.kt)("p",null,"While this sounds complicated, the rules are pretty straight forward. Examples like the one above are also rather academic and have little relevance for real applications. "),(0,r.kt)("h3",{id:"example-3"},"Example 3"),(0,r.kt)("p",null,"Here's a more realistic example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"thunk<LoadUser> {\n    dispatch(UserLoading)\n    val result = repo.loadUser()\n    dispatch(UserLoaded(result))\n}\n\nthunk<UserLoading> {\n    dispatch(AccountLoading)\n    val result = repo.loadAccount()\n    dispatch(AccountLoaded(result))\n}\n\nreduce<UserLoading> {\n    // this won't be executed because the second thunk captures the UserLoading action\n}\n\nreduce<AccountLoading> {\n    state.copy(loading = true)\n}\n\nreduce<UserLoaded> {\n    state.copy(user = action.result)\n}\n\nreduce<AccountLoaded> {\n    state.copy(loading = false, account = action.result)\n}\n")))}h.isMDXComponent=!0}}]);