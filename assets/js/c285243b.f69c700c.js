"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[580],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),s=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return i.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=s(n),h=a,f=p["".concat(c,".").concat(h)]||p[h]||d[h]||r;return n?i.createElement(f,l(l({ref:t},u),{},{components:n})):i.createElement(f,l({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<r;s++)l[s]=n[s];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6929:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return r},metadata:function(){return o},toc:function(){return s}});var i=n(3117),a=(n(7294),n(3905));const r={id:"initializer",title:"Initializer",sidebar_label:"Initializer",hide_title:!0},l=void 0,o={unversionedId:"architecture/bloc/initializer",id:"architecture/bloc/initializer",title:"Initializer",description:"Definition",source:"@site/docs/architecture/bloc/initializer.md",sourceDirName:"architecture/bloc",slug:"/architecture/bloc/initializer",permalink:"/Kotlin-Bloc/docs/architecture/bloc/initializer",draft:!1,tags:[],version:"current",frontMatter:{id:"initializer",title:"Initializer",sidebar_label:"Initializer",hide_title:!0},sidebar:"architectureSidebar",previous:{title:"Thunk",permalink:"/Kotlin-Bloc/docs/architecture/bloc/thunk"},next:{title:"Bloc Builder",permalink:"/Kotlin-Bloc/docs/architecture/bloc/bloc_builder"}},c={},s=[{value:"Definition",id:"definition",level:2},{value:"Context",id:"context",level:3},{value:"reduce()",id:"reduce",level:3},{value:"dispatch()",id:"dispatch",level:3},{value:"Execution",id:"execution",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Example 3",id:"example-3",level:3}],u={toc:s};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"definition"},"Definition"),(0,a.kt)("p",null,"Initializers are functions executed when the bloc is created, typically to kick off some initial load. They can execute asynchronous code and dispatch actions to be processed by thunks and reducers. Initializers are executed exactly once during the ",(0,a.kt)("a",{parentName:"p",href:"./lifecycle"},"Lifecycle")," of a bloc."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"If more than one initializer is defined, building the bloc will fail with a runtime exception.")),(0,a.kt)("h3",{id:"context"},"Context"),(0,a.kt)("p",null,"An initializer is called with a ",(0,a.kt)("inlineCode",{parentName:"p"},"InitializerContext")," as receiver. The context is giving access to the current ",(0,a.kt)("inlineCode",{parentName:"p"},"State"),", a ",(0,a.kt)("inlineCode",{parentName:"p"},"Dispatcher"),' and a function to "reduce" state directly:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"public data class InitializerContext<State, Action>(\n    val getState: GetState<State>,\n    val dispatch: Dispatcher<Action>,\n    val reduce: (proposal: Proposal) -> Unit\n)\n")),(0,a.kt)("h3",{id:"reduce"},"reduce()"),(0,a.kt)("p",null,"Analogous to thunks, initializers have a ",(0,a.kt)("inlineCode",{parentName:"p"},"reduce()")," function to eliminate boilerplate code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"onCreate {\n    reduce(getState().copy(loading = true))\n    val books = repository.load()\n    reduce(state.copy(loading = false, books = books))\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"reduce()")," will suspend till the queued reducer was executed. This is identical to ",(0,a.kt)("a",{parentName:"p",href:"thunk#reduce"},"how reduce() works in thunks")," and guarantees that this always succeeds:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"onCreate {\n    reduce(newState)                    // <- suspends till the state reduction is done\n    assertEquals(getState(), newState)  // <- assertion is always true\n}\n")),(0,a.kt)("h3",{id:"dispatch"},"dispatch()"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"dispatch()")," will suspend till the triggered reducer was executed. This is identical to ",(0,a.kt)("a",{parentName:"p",href:"thunk#dispatch"},"how dispatch() works in thunks")," and guarantees that this always succeeds:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"onCreate {\n    val state = getState()\n    dispatch(Increment)                 // <- suspends till the reducer has run\n    assertEquals(getState(), state + 1) // <- assertion is always true\n}\nreduce<Increment> {\n    state + 1\n}\n")),(0,a.kt)("h2",{id:"execution"},"Execution"),(0,a.kt)("p",null,"Actions dispatched by the initializer are processed by thunks and reducers even before ",(0,a.kt)("inlineCode",{parentName:"p"},"onStart()")," is called. Actions that are not dispatched by the initializer however are ignored before the bloc transitions to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Started")," state (see ",(0,a.kt)("a",{parentName:"p",href:"lifecycle"},"Lifecycle"),"). This guarantees that the initializer runs and finishes before any thunks and reducers are executed. The only exception to that rule is if the initializer launches asynchronous code e.g. via ",(0,a.kt)("a",{parentName:"p",href:"coroutine_launcher"},"launch")," and would dispatch actions from there (so don't do this)."),(0,a.kt)("h3",{id:"example-1"},"Example 1"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"thunk<Load> {\n    dispatch(Loading)\n    val result = repository.getPosts()\n    dispatch(Loaded(result))\n}\n\nonCreate { \n    if (getState().isEmpty()) dispatch(Load) \n}\n")),(0,a.kt)("p",null,"The order of declaration is irrelevant, the initializer will always be called first. "),(0,a.kt)("p",null,"The thunk's asynchronous code could also be in the initializer itself:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"onCreate { \n    if (getState().isEmpty()) {\n        dispatch(Loading)\n        val result = repository.getPosts()\n        dispatch(Loaded(result))\n    }\n}\n")),(0,a.kt)("h3",{id:"example-2"},"Example 2"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},'val lifecycleRegistry = LifecycleRegistry()\nval context = BlocContextImpl(lifecycleRegistry)\n\nval bloc = bloc<Int, Int, Unit>(context, 1) {\n    onCreate {\n        dispatch(2)\n    }\n    reduce { getState() + action }\n}\n\n// initializer executes -> reduce state\nlifecycleRegistry.onCreate()\ndelay(50)\nassertEquals(3, bloc.value)\n\n// this action however will be ignored\nbloc.send(3)\ndelay(50)\nassertEquals(3, bloc.value)\n\n// after onStart() -> "regular" reducer is being executed\nlifecycleRegistry.onStart()\nbloc.send(3)\ndelay(50)\nassertEquals(6, bloc.value)\n')),(0,a.kt)("h3",{id:"example-3"},"Example 3"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-kotlin"},"val lifecycleRegistry = LifecycleRegistry()\nval context = BlocContextImpl(lifecycleRegistry)\n\nval bloc = bloc<Int, Int, Unit>(context, 1) {\n    onCreate {\n        delay(1000)\n        dispatch(2)\n    }\n    reduce { getState() + action }\n}\n\nlifecycleRegistry.onCreate()\n\n// this action will be ignored (also the initializer is still running)\nbloc.send(3)\ndelay(50)\nassertEquals(1, bloc.value)\n\nlifecycleRegistry.onStart()\n\n// this action will be queued... (and the initializer is still running)\nbloc.send(3)\ndelay(50)\nassertEquals(1, bloc.value)\n\n// ...and processed once the initializer is done\ndelay(900)\nassertEquals(6, bloc.value)\n")))}d.isMDXComponent=!0}}]);