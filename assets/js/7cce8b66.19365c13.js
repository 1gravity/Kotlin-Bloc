"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[800],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},b=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),b=c(n),m=o,d=b["".concat(s,".").concat(m)]||b[m]||u[m]||i;return n?r.createElement(d,l(l({ref:t},p),{},{components:n})):r.createElement(d,l({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=b;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a.mdxType="string"==typeof e?e:o,l[1]=a;for(var c=2;c<i;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}b.displayName="MDXCreateElement"},6888:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return a},metadata:function(){return c},toc:function(){return u}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),l=["components"],a={id:"ios_bloc_observer",title:"Bloc Observer",sidebar_label:"Bloc Observer",hide_title:!0},s=void 0,c={unversionedId:"extensions/ios/ios_bloc_observer",id:"extensions/ios/ios_bloc_observer",title:"Bloc Observer",description:"BlocObserver",source:"@site/docs/extensions/ios/bloc_observer.md",sourceDirName:"extensions/ios",slug:"/extensions/ios/ios_bloc_observer",permalink:"/Kotlin-Bloc/docs/extensions/ios/ios_bloc_observer",draft:!1,tags:[],version:"current",frontMatter:{id:"ios_bloc_observer",title:"Bloc Observer",sidebar_label:"Bloc Observer",hide_title:!0},sidebar:"extensionsSidebar",previous:{title:"Bloc Component",permalink:"/Kotlin-Bloc/docs/extensions/ios/ios_bloc_component"},next:{title:"Motivation",permalink:"/Kotlin-Bloc/docs/extensions/redux/redux_motivation"}},p={},u=[{value:"BlocObserver",id:"blocobserver",level:2}],b={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,l);return(0,i.kt)("wrapper",(0,r.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"blocobserver"},"BlocObserver"),(0,i.kt)("p",null,"A bloc exposes a ",(0,i.kt)("inlineCode",{parentName:"p"},"StateStream")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"SideEffectStream")," which are essentially Kotlin Flows. The question is how can a Kotlin Flow be observed in Swift? Different solutions have been proposed:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://betterprogramming.pub/using-kotlin-flow-in-swift-3e7b53f559b6"},"https://betterprogramming.pub/using-kotlin-flow-in-swift-3e7b53f559b6")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://johnoreilly.dev/posts/kotlinmultiplatform-swift-combine_publisher-flow/"},"https://johnoreilly.dev/posts/kotlinmultiplatform-swift-combine_publisher-flow/")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://dev.to/touchlab/working-with-kotlin-coroutines-and-rxswift-24fa"},"https://dev.to/touchlab/working-with-kotlin-coroutines-and-rxswift-24fa")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/FutureMind/koru"},"https://github.com/FutureMind/koru")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://touchlab.co/kotlin-coroutines-swift-revisited/"},"https://touchlab.co/kotlin-coroutines-swift-revisited/"))),(0,i.kt)("p",null,"Some of these solutions are more generic than what we need for our purpose which is simply be able to observe the streams in SwiftUI and update the view when state changes."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/1gravity/Kotlin-Bloc/blob/master/iosApp/iosApp/utils/BlocObserver.swift"},"BlocObserver")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"observes both streams and exposes them as ",(0,i.kt)("a",{parentName:"li",href:"https://developer.apple.com/documentation/combine/published"},"@Published")," properties (-> the ",(0,i.kt)("inlineCode",{parentName:"li"},"BlocObserver")," needs to be an ",(0,i.kt)("a",{parentName:"li",href:"https://developer.apple.com/documentation/combine/observableobject"},"ObservableObject"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"state")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sideEffect")," are the @Published properties than can be observed by the view"),(0,i.kt)("li",{parentName:"ul"},"creates a lifecycle used to ",(0,i.kt)("inlineCode",{parentName:"li"},"unsubscribe"),' from the bloc, the lifecycle is tied to the "lifecycle" of the ',(0,i.kt)("inlineCode",{parentName:"li"},"BlocObserver")," object itself")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-swift"},"    private let holder = BlocHolder { CalculatorKt.bloc(context: $0) }\n    \n    @ObservedObject\n    private var model: BlocObserver<CalculatorState, CalculatorAction, KotlinUnit>\n\n    init() {\n        self.model = BlocObserver(self.holder.value)\n    }\n")),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The lifecycle is tied to the lifecycle of the ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocObserver")," object itself. As with ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocHolder")," that means that you need to keep an explicit reference to that object like in the example above. See also: ",(0,i.kt)("a",{parentName:"p",href:"/Kotlin-Bloc/docs/extensions/ios/ios_bloc_holder#"},"BlocHolder")))))}m.isMDXComponent=!0}}]);