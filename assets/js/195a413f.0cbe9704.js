"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[615],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=s(n),h=r,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=p;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},838:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],c={id:"reducer",title:"Reducer",sidebar_label:"Reducer",hide_title:!0},l=void 0,s={unversionedId:"architecture/bloc/reducer",id:"architecture/bloc/reducer",title:"Reducer",description:"Definition",source:"@site/docs/architecture/bloc/reducer.md",sourceDirName:"architecture/bloc",slug:"/architecture/bloc/reducer",permalink:"/Kotlin-Bloc/docs/architecture/bloc/reducer",draft:!1,tags:[],version:"current",frontMatter:{id:"reducer",title:"Reducer",sidebar_label:"Reducer",hide_title:!0},sidebar:"architectureSidebar",previous:{title:"Overview",permalink:"/Kotlin-Bloc/docs/architecture/bloc/"},next:{title:"Thunk",permalink:"/Kotlin-Bloc/docs/architecture/bloc/thunk"}},u={},d=[{value:"Definition",id:"definition",level:2},{value:"Context",id:"context",level:3},{value:"Side Effect",id:"side-effect",level:3},{value:"Execution",id:"execution",level:2},{value:"Concurrency",id:"concurrency",level:3},{value:"Matching",id:"matching",level:2},{value:"Without Action",id:"without-action",level:3},{value:"With Action",id:"with-action",level:3},{value:"A Matter of Taste",id:"a-matter-of-taste",level:2}],p={toc:d};function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"definition"},"Definition"),(0,i.kt)("p",null,"To reiterate:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A reducer is a function that receives the current state and an action object, decides how to update the state if necessary, and returns the new state: (state, action) => newState",(0,i.kt)("br",{parentName:"p"}),"\n","(",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow"},"https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow"),")")),(0,i.kt)("p",null,"While the offical Redux reducer definition captures the essence, reducers in the context of ",(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc")," are a bit more complex: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend (State, Action, CoroutineScope) -> Proposal\n")),(0,i.kt)("p",null,'Compared to a Redux reducer, "our" reducer is:'),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"suspending"),(0,i.kt)("li",{parentName:"ol"},"takes a CoroutineScope as parameter (on top of the ",(0,i.kt)("inlineCode",{parentName:"li"},"State")," and the ",(0,i.kt)("inlineCode",{parentName:"li"},"Action"),")"),(0,i.kt)("li",{parentName:"ol"},"returns a ",(0,i.kt)("inlineCode",{parentName:"li"},"Proposal")," instead of ",(0,i.kt)("inlineCode",{parentName:"li"},"State"))),(0,i.kt)("h3",{id:"context"},"Context"),(0,i.kt)("p",null,"A reducer is called with a ",(0,i.kt)("inlineCode",{parentName:"p"},"ReducerContext")," as receiver. The context giving access to the current ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," that triggered the reducer's execution and a CoroutineScope:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"public data class ReducerContext<State, Action>(\n    val state: State,\n    val action: Action,\n    val coroutineScope: CoroutineScope\n)\n")),(0,i.kt)("p",null,"A typical reducer would evaluate the action and apply some transformation to the immutable state like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce {\n    when (action) {\n        is PostLoading -> state.copy(loading = true)\n        is PostLoaded -> state.copy(loading = false, post = action.result)\n    }\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CoroutineScope")," is only used in the ",(0,i.kt)("a",{parentName:"p",href:"../../extensions/redux/redux_motivation"},"Redux Extension"),". It's tied to the lifecycle of the bloc and will be cancelled when the bloc is destroyed."),(0,i.kt)("h3",{id:"side-effect"},"Side Effect"),(0,i.kt)("p",null,"A side effect is a one-off event like a navigation event, an analytics event or an event to display a toast. The idea of side effects and some of the syntax was inspired by ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/genaku/Reduce"},"Reduce"),". In ",(0,i.kt)("inlineCode",{parentName:"p"},"Reduce")," a reducer always returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," which is a class wrapping ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," and a list of side effects. ",(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc"),"'s reducers return ",(0,i.kt)("inlineCode",{parentName:"p"},"Proposals")," by default while ",(0,i.kt)("inlineCode",{parentName:"p"},"Effects")," require a a bit more typing."),(0,i.kt)("p",null,"Default: reducer returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Proposal"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// reducer without side effects\nsuspend (State, Action, CoroutineScope) -> Proposal\n")),(0,i.kt)("p",null,"Exception: reducer returns ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect<Proposal, SideEffect>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// reducer with side effects\nsuspend (State, Action, CoroutineScope) -> Effect<Proposal, SideEffect>\n\npublic data class Effect<Proposal : Any, SideEffect : Any>(\n    val proposal: Proposal?,\n    val sideEffects: List<SideEffect>\n)\n")),(0,i.kt)("p",null,"Since most reducers have no side effects, using that case as the default makes sense. If side effects are required, the syntax is slightly more complex:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class State(val loading: Boolean = false, val post: Post? = null)\n\nsealed class Action\nobject Clicked : Action()\n\nsealed class SideEffect\nobject Open : SideEffect()\nobject LogEvent : SideEffect()\n\nfun bloc(context: BlocContext) =\n    bloc<State, Action, SideEffect, State>(context, State()) {\n        // reducer without side effects\n        reduce<Clicked> {\n            state.copy(loading = true)\n        }\n\n        // reducer with two side effects\n        reduceAnd<Clicked> {\n            state.copy(loading = true) and Open and LogEvent\n        }\n\n        // reducer without side effects\n        reduceAnd<Clicked> {\n            state.copy(loading = true).noSideEffect()\n        }\n\n        // no state reduction, only one side effect\n        sideEffect<Clicked> { \n            Open\n        }        \n    }\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"reduceAnd")," is the builder function to use if a reducer has side effects. The ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," operator can be used to combine state and side effects into an ",(0,i.kt)("inlineCode",{parentName:"p"},"Effect")," instead of instantiating the object directly. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/genaku/Reduce"},"Reduce")," uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"+")," operator instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"and")," which makes for some neat syntax but also interferes with mathematical operations."),(0,i.kt)("h2",{id:"execution"},"Execution"),(0,i.kt)("p",null,"When an ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," is sent to the bloc, it will determine whether there are matching thunks. If there are, it will be put into the thunk queue. If there are no matching thunks but matching reducers, the action will be put into the reducer queue. The queues are ",(0,i.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/channels.html"},"Channels")," which are processed asynchronously."),(0,i.kt)("p",null,"If there's a matching thunk and a matching reducer, only the thunk will be executed like in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"thunk<Increment> {\n    // thunk code will be executed\n}\n\nreduce<Increment> {\n    // reduce code won't be executed\n}\n")),(0,i.kt)("p",null,'This behavior makes sense because thunks are like Redux thunk-middleware. They execute before the reducers do. They can however dispatch actions to the "next" thunk or reducer. In this example the reducer is called when the thunk dispatches the ',(0,i.kt)("inlineCode",{parentName:"p"},"Increment")," action."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"thunk<Increment> {\n    // do asynchronous thunk stuff\n    dispatch(Increment)\n}\n\nreduce<Increment> {\n    // reduce code will be executed\n}\n")),(0,i.kt)("p",null,"What happens if there are two matching reducers?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce<Increment> {\n    // will be executed\n}\n\nreduce<Increment> {\n    // won't be executed\n}\n\nreduce {\n    // won't be executed\n}\n")),(0,i.kt)("p",null,"This behavior also makes sense since state must be reduced only once. Whichever matching reducer is declared first is the one being called. While the order of declaration is relevant for reducers (if they match the same action), it's not for thunks and reducers, thunks will always be executed first."),(0,i.kt)("p",null,"What about side effects?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce<Increment> {\n    // will be executed\n}\n\nsideEffect<Increment> {\n    // will also be executed\n}\n\nsideEffect<Increment> {\n    // this one too will be executed\n}\n\nreduceAnd<Increment> {\n    // won't be executed\n}\n")),(0,i.kt)("p",null,'Since "pure" side effects functions (',(0,i.kt)("inlineCode",{parentName:"p"},"sideEffect { }")," block) aren't reducing state, they will always be executed."),(0,i.kt)("h3",{id:"concurrency"},"Concurrency"),(0,i.kt)("p",null,"To ensure a predictable order of execution and to make sure reducers don't reduce \"stale\" state, they are always executed sequentially. If multiple actions are sent to the bloc, those actions will be processed in the order they were received and they won't run in parallel. Here's an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed class Action\nobject Increment : Action()\nobject Decrement : Action()\n\nprivate val bloc by getOrCreate { bloc<Int, Action>(it, 1) {\n    reduce<Increment> {\n        delay(10000)\n        state + 1\n    }\n    reduce<Decrement> {\n        delay(5000)\n        state - 1\n    }\n} }\n")),(0,i.kt)("p",null,"Even if ",(0,i.kt)("inlineCode",{parentName:"p"},"Increment")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Decrement")," are sent in quick succession, ",(0,i.kt)("inlineCode",{parentName:"p"},"Increment")," will always be processed first and the reducer will finish before the ",(0,i.kt)("inlineCode",{parentName:"p"},"Decrement")," action is processed."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Increment")," reducer starts, waits 10 seconds and sets the counter to 2"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"Decrement")," reducer starts, waits 5 seconds and sets the counter to 1 ")),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"This behavior is true for reducers triggered by an action (Redux style) or triggered by a function (MVVM+ style) (see ",(0,i.kt)("a",{parentName:"p",href:"/Kotlin-Bloc/docs/architecture/blocowner/bloc_owner#blocowner"},"BlocOwner"),"). As a matter of fact, both types of reducers are sent to the same queue to be processed."))),(0,i.kt)("h2",{id:"matching"},"Matching"),(0,i.kt)("p",null,"So what's a match?"),(0,i.kt)("p",null,"In the case of reducers, we have a match if:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"a reducer doesn't define an action explicitly (catch all reducer) "),(0,i.kt)("li",{parentName:"ol"},"a reducer defines an action identical to the sent action (",(0,i.kt)("inlineCode",{parentName:"li"},"KClass.isInstance"),")")),(0,i.kt)("h3",{id:"without-action"},"Without Action"),(0,i.kt)("p",null,"A reducer not defining an action explicitly is like a Redux reducer, a catch-all function to process a bunch of actions typically using a when statement like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce {\n    when (action) {\n        is Increment -> state + 1\n        is Decrement -> state - 1\n    }\n}\n")),(0,i.kt)("h3",{id:"with-action"},"With Action"),(0,i.kt)("p",null,"A reducer defining an action will be executed only if the sent action matches the reducer's action.\nThere are two different action types requiring a different syntax:"),(0,i.kt)("p",null,"If an action is a ",(0,i.kt)("inlineCode",{parentName:"p"},"class"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"object")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"data class"),", the syntax is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce<Increment> { state + 1 }\n\nreduce<Decrement> { state - 1 }\n\n// Action definition\nsealed class Action\nobject Increment : Action()\nobject Decrement : Action()\n")),(0,i.kt)("p",null,"If an action is an ",(0,i.kt)("inlineCode",{parentName:"p"},"enum class"),", the syntax is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce(Action.Increment) { state + 1 }\n\nreduce(Action.Decrement) { state - 1 }\n\n// Action definition\nenum class Action { \n    Increment, \n    Decrement \n}\n")),(0,i.kt)("h2",{id:"a-matter-of-taste"},"A Matter of Taste"),(0,i.kt)("p",null,"Reducers can be catch-all reducers or they can be single-action reducers (we can also use a combination of the two). Catch-all reducers are the traditional/Redux style of writing reducers."),(0,i.kt)("p",null,"Catch-all reducers make sense if you want the reducer logic in one place like in this (calculator) example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce {\n    try {\n        val newState = state.resetErrors()\n        when (action) {\n            Clear -> CalculatorState()\n            Equals -> newState.equals()\n            Add -> newState.apply(Operator.Add)\n            Subtract -> newState.apply(Operator.Subtract)\n            Multiply -> newState.apply(Operator.Multiply)\n            Divide -> newState.apply(Operator.Divide)\n            PlusMinus -> newState.plusMinus()\n            Percentage -> newState.percentage()\n            Period -> newState.period()\n            is Digit -> newState.digit(action.digit)\n        }\n    } catch (ex: Exception) {\n        CalculatorState.error(ex.message)\n    }\n}\n")),(0,i.kt)("p",null,"Using single-action reducers makes sense if the reducer logic is more complex like in this example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"reduce<Add> {\n    with (state.resetErrors()) {\n        runCatching {\n            val state = if (register1.isNotEmpty() && register2.isNotEmpty()) equals() else this\n            if (state.register1.isEmpty())\n                state\n            else state.copy(\n                register1 = Register(),\n                register2 = if (state.register1.isNotEmpty()) state.register1 else state.register2,\n                operator = op\n            )\n        }.mapToState()\n    }\n}\n\nreduce<Equals> {\n    with (state.resetErrors()) {\n        runCatching {\n            if (register2.isEmpty()) return this\n            val reg1 = when (operator) {\n                Operator.Add -> register2 + register1\n                Operator.Subtract -> register2 - register1\n                Operator.Multiply -> register2 * register1\n                Operator.Divide -> register2 / register1\n                else -> register1\n            }\n            copy(register1 = reg1, register2 = Register(), operator = null)\n        }.mapToState()\n    }\n}\n")),(0,i.kt)("p",null,'It\'s a "matter of taste", which style you prefer. While the traditional/Redux style is to have reducers dealing with different actions, ',(0,i.kt)("a",{parentName:"p",href:"https://dev.to/feresr/a-case-against-the-mvi-architecture-pattern-1add"},"this article")," advocates for splitting reducers into smaller chunks. "),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://orbit-mvi.org/"},"Orbit")," is one of the frameworks championing the MVVM+ style (that's what they call it in ",(0,i.kt)("a",{parentName:"p",href:"https://appmattus.medium.com/top-android-mvi-libraries-in-2021-de1afe890f27"},"this article"),") and it served as inspiration for some of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc")," design although they take the idea one step further (see ",(0,i.kt)("a",{parentName:"p",href:"../blocowner/bloc_owner"},"BlowOwner"),")."))}h.isMDXComponent=!0}}]);