"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7614],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(n),u=i,h=m["".concat(c,".").concat(u)]||m[u]||p[u]||a;return n?o.createElement(h,r(r({ref:t},d),{},{components:n})):o.createElement(h,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var s=2;s<a;s++)r[s]=n[s];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3470:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return r},default:function(){return p},frontMatter:function(){return a},metadata:function(){return l},toc:function(){return s}});var o=n(3117),i=(n(7294),n(3905));const a={id:"android_bloc_context",title:"Android BlocContext",sidebar_label:"BlocContext",hide_title:!0},r=void 0,l={unversionedId:"extensions/android/android_bloc_context",id:"extensions/android/android_bloc_context",title:"Android BlocContext",description:"Introduction",source:"@site/docs/extensions/android/bloc_context.md",sourceDirName:"extensions/android",slug:"/extensions/android/android_bloc_context",permalink:"/Kotlin-Bloc/docs/extensions/android/android_bloc_context",draft:!1,tags:[],version:"current",frontMatter:{id:"android_bloc_context",title:"Android BlocContext",sidebar_label:"BlocContext",hide_title:!0},sidebar:"extensionsSidebar",previous:{title:"Overview",permalink:"/Kotlin-Bloc/docs/extensions/overview"},next:{title:"Data Binding",permalink:"/Kotlin-Bloc/docs/extensions/android/android_data_binding"}},c={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Lifecycle",id:"lifecycle",level:2},{value:"ViewModel",id:"viewmodel",level:3},{value:"Activity/Fragment",id:"activityfragment",level:3},{value:"The Key",id:"the-key",level:4}],d={toc:s};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"If you haven't read the chapter about ",(0,i.kt)("a",{parentName:"p",href:"../../architecture/bloc/bloc_context"},"BlocContext")," yet, you should do so. It's crucial to understanding how blocs are tied to the different Android lifecycles."),(0,i.kt)("p",null,"Creating a bloc always requires a ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocContext"),". On Android that process is rather complicated (fear not, that's why there are the extensions discussed here). The main part needed to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocContext")," is the correct ",(0,i.kt)("a",{parentName:"p",href:"../../architecture/bloc/lifecycle"},"Lifecycle"),"."),(0,i.kt)("h2",{id:"lifecycle"},"Lifecycle"),(0,i.kt)("p",null,"As explained ",(0,i.kt)("a",{parentName:"p",href:"../../architecture/bloc/lifecycle"},"here"),", there are four lifecycles. What we need for the ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocContext")," is an ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/arkivanov/Essenty"},"Essenty Lifecycle")," which is the one determining when the bloc is created, started, stopped and destroyed."),(0,i.kt)("p",null,"The view lifecycle can be an Activity/Fragment lifecycle, a Composable lifecycle or something similar, depending on what tech is being used for the ",(0,i.kt)("inlineCode",{parentName:"p"},"View"),". A bloc should not be tied to that lifecycle since it's too short lived and it would typically lose state upon configuration changes. "),(0,i.kt)("p",null,'On Android side we want a ViewModel "lifecycle" to be the one connecting the ',(0,i.kt)("inlineCode",{parentName:"p"},"View")," lifecycle and the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/arkivanov/Essenty"},"Essenty Lifecycle"),"."),(0,i.kt)("h3",{id:"viewmodel"},"ViewModel"),(0,i.kt)("p",null,"In an Android ViewModel, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"blocContext()")," extension function to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocContext"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"blocContext()"),' creates a context that is tied to the ViewModel\'s "lifecycle":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class CounterViewModel : ViewModel() {\n\n    private val bloc = bloc(blocContext())\n")),(0,i.kt)("p",null,"Those familiar with the Android ViewModel know that those ViewModels have a really basic ",(0,i.kt)("a",{parentName:"p",href:"https://developer.android.com/topic/libraries/architecture/viewmodel#lifecycle"},"lifecycle")," and not one that can be retrieved like the Activity's lifecycle. Most frameworks solve that problem by providing a BaseViewModel class that uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"onCleared()")," function to create an artificial ViewModel lifecycle. That solution forces you to extend their BaseViewModel, an annoying solution in a language that doesn't support multiple inheritance. ",(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc")," offers a better solution using coroutines / ",(0,i.kt)("a",{parentName:"p",href:"https://developer.android.com/topic/libraries/architecture/coroutines#viewmodelscope"},"viewModelScope")," to tie into the ViewModel lifecycle so there's no need to extend a BaseViewModel."),(0,i.kt)("h3",{id:"activityfragment"},"Activity/Fragment"),(0,i.kt)("p",null,"Android ViewModels are great to retain state across configuration changes but if the business logic is implemented with a bloc in a platform agnostic way, they become just proxies between the ",(0,i.kt)("inlineCode",{parentName:"p"},"View")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc"),'. Their only "added-value" would be to provide the ',(0,i.kt)("a",{parentName:"p",href:"#lifecycle"},"lifecycle"),". Some frameworks solved this by providing a platform independent ViewModel implementation (like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/touchlab/KaMPKit/blob/main/docs/GENERAL_ARCHITECTURE.md"},"KaMPKit"),").  "),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Kotlin Bloc")," has a better solution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class CounterActivity : AppCompatActivity() {\n\n    private val bloc by getOrCreate { bloc(it) }\n")),(0,i.kt)("p",null,"That small piece of code ",(0,i.kt)("inlineCode",{parentName:"p"},"getOrCreate { bloc(it) }")," does a lot for you:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"it creates a ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewModel")," "),(0,i.kt)("li",{parentName:"ul"},"it creates an ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/arkivanov/Essenty"},"Essenty ",(0,i.kt)("inlineCode",{parentName:"a"},"Lifecycle"))," tied to the ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewModel"),"'s lifecycle"),(0,i.kt)("li",{parentName:"ul"},"it creates an ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/arkivanov/Essenty"},"Essenty ",(0,i.kt)("inlineCode",{parentName:"a"},"InstanceKeeper"))," tied to the ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewModel")),(0,i.kt)("li",{parentName:"ul"},"it creates a ",(0,i.kt)("inlineCode",{parentName:"li"},"BlocContext")," using the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/arkivanov/Essenty"},"Essenty ",(0,i.kt)("inlineCode",{parentName:"a"},"Lifecycle"))),(0,i.kt)("li",{parentName:"ul"},"the ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewModel")," is stored in the Activity's ",(0,i.kt)("a",{parentName:"li",href:"https://developer.android.com/reference/android/arch/lifecycle/ViewModelStore"},"ViewModelStore")),(0,i.kt)("li",{parentName:"ul"},"it creates the ",(0,i.kt)("inlineCode",{parentName:"li"},"bloc")," and stores it in the ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/arkivanov/Essenty"},"Essenty ",(0,i.kt)("inlineCode",{parentName:"a"},"InstanceKeeper"))),(0,i.kt)("li",{parentName:"ul"},"it does all that lazily and only if the ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewModel")," isn't already in the ",(0,i.kt)("inlineCode",{parentName:"li"},"ViewModelStore"))),(0,i.kt)("p",null,"Ultimately you get a ",(0,i.kt)("inlineCode",{parentName:"p"},"bloc")," that is tied to a ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewModel")," (which is created under-the-hood) with a lifecycle that is determined by the ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewModel"),"'s lifecycle"),(0,i.kt)("p",null,"The expression's builder block receives ",(0,i.kt)("inlineCode",{parentName:"p"},"it")," = ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocContext")," as argument and can use it to instantiate a bloc or some other component that needs a ",(0,i.kt)("inlineCode",{parentName:"p"},"BlocContext"),". Here's another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class PostsActivity : AppCompatActivity() {\n    \n    private val component: PostsComponent by getOrCreate { PostsComponentImpl(it) }\n")),(0,i.kt)("p",null,"or "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"class BooksActivity : AppCompatActivity() {\n\n    private val useCase: BooksUseCase by getOrCreate { BooksUseCaseImpl(it, BooksRepositoryImpl()) }\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Instead of creating a hard dependency on the implementing component ",(0,i.kt)("inlineCode",{parentName:"p"},"PostsComponentImpl"),", we can use dependency injection. With Koin we would do:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"private val component: PostsComponent by getOrCreate {\n    get(parameters = { parametersOf(it) })\n}\n\n// with this definition in the Koin module:\nfactory<PostsComponent> { PostsComponentImpl(it.get()) }\n"))),(0,i.kt)("h4",{id:"the-key"},"The Key"),(0,i.kt)("p",null,"Some might have noticed that ",(0,i.kt)("inlineCode",{parentName:"p"},"getOrCreate()")," has a optional ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," parameter. The ",(0,i.kt)("inlineCode",{parentName:"p"},"key")," is needed to store/retrieve the component instantiated in the lambda / builder block and it's default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"Component::class"),". If the builder block returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Bloc")," instance then the key value is ",(0,i.kt)("inlineCode",{parentName:"p"},"com.onegravity.bloc.Bloc"),". That key ignores the bloc's generic types (which are erased at runtime) that make the bloc unique. If ",(0,i.kt)("inlineCode",{parentName:"p"},"getOrCreate()")," is used to create/retrieve blocs with different generic types in the context of the same Activity, it would use the same key for different blocs which would lead to a ",(0,i.kt)("inlineCode",{parentName:"p"},"ClassCastException"),"."),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/1gravity/Kotlin-Bloc/tree/master/androidApp/src/main/kotlin/com/onegravity/bloc/posts"},"Posts sample app"),", the two fragments use different blocs but obviously run in the context of the same Activity (and thus use the same ",(0,i.kt)("inlineCode",{parentName:"p"},"ViewModelStore"),"). "),(0,i.kt)("p",null,"Doing this would crash the app when the second bloc is created (it would find the ",(0,i.kt)("inlineCode",{parentName:"p"},"Posts")," bloc object and return it because that one is stored under the ",(0,i.kt)("inlineCode",{parentName:"p"},"com.onegravity.bloc.Bloc")," key):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},"// PostsFragment\nval bloc: PostsBloc by getOrCreate { Posts.bloc(it) }\n\n// PostFragment\nval bloc: PostBloc by getOrCreate { Post.bloc(it) }\n")),(0,i.kt)("p",null,"Providing a unique key solves the problem:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-kotlin"},'// PostsFragment\nval bloc: PostsBloc by getOrCreate("posts") { Posts.bloc(it) }\n\n// PostFragment\nval bloc: PostBloc by getOrCreate("post") { Post.bloc(it) }\n')))}p.isMDXComponent=!0}}]);